// app/src/main/java/com/example/textselector/MainActivity.kt
package com.example.textselector

import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.os.Bundle
import android.widget.ArrayAdapter
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import com.example.textselector.databinding.ActivityMainBinding
import org.json.JSONArray
import org.json.JSONObject

class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding

    // Key to store texts in SharedPreferences as a JSON array.
    private val PREFS_KEY = "saved_texts"

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // If started with a SEND intent, load the text.
        if (intent?.action == "android.intent.action.SEND" && intent.type == "text/plain") {
            intent.getStringExtra("android.intent.extra.TEXT")?.let {
                binding.pinnedEditText.setText(it)
            }
        } else {
            // Otherwise, load a sample text
            binding.pinnedEditText.setText(getLongText())
        }

        // Paste button: get text from clipboard.
        binding.pasteButton.setOnClickListener {
            val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
            val clipData = clipboard.primaryClip
            if (clipData != null && clipData.itemCount > 0) {
                val pasteText = clipData.getItemAt(0).text.toString()
                binding.pinnedEditText.setText(pasteText)
            }
        }

        // Search: scroll to first occurrence of the search term.
        binding.searchButton.setOnClickListener {
            val searchTerm = binding.searchEditText.text.toString()
            if (searchTerm.isEmpty()) return@setOnClickListener

            val text = binding.pinnedEditText.text.toString()
            // Start search from after the current selection.
            val startIndex = binding.pinnedEditText.selectionEnd
            var index = text.indexOf(searchTerm, startIndex)
            // If not found after current selection, wrap-around to search from the beginning.
            if (index == -1 && startIndex > 0) {
                index = text.indexOf(searchTerm, 0)
            }
            if (index >= 0) {
                binding.pinnedEditText.setSelection(index, index + searchTerm.length)
                binding.pinnedEditText.requestFocus()
            }
        }


        // Save: persist the current text and pin positions.
        binding.saveButton.setOnClickListener {
            saveCurrentText()
        }

        // Load: show saved texts in a dialog.
        binding.loadButton.setOnClickListener {
            loadSavedTexts()
        }
    }

    private fun getLongText(): String {
        val lorem = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. "
        return lorem.repeat(300)
    }

    /** Save the current text (and pin positions) to SharedPreferences.  */
    private fun saveCurrentText() {
        val prefs = getSharedPreferences("TextSelectorPrefs", Context.MODE_PRIVATE)
        val jsonArray = JSONArray(prefs.getString(PREFS_KEY, "[]"))
        val obj = JSONObject().apply {
            put("text", binding.pinnedEditText.text.toString())
            put("pinnedStart", binding.pinnedEditText.pinnedStart ?: JSONObject.NULL)
            put("pinnedEnd", binding.pinnedEditText.pinnedEnd ?: JSONObject.NULL)
        }
        jsonArray.put(obj)
        prefs.edit().putString(PREFS_KEY, jsonArray.toString()).apply()
    }

    /** Load saved texts and let the user choose one to load.  */
    private fun loadSavedTexts() {
        val prefs = getSharedPreferences("TextSelectorPrefs", Context.MODE_PRIVATE)
        val jsonArray = JSONArray(prefs.getString(PREFS_KEY, "[]"))
        if (jsonArray.length() == 0) return

        // Create a simple list (using the first 40 characters as a preview).
        val listItems = mutableListOf<String>()
        val texts = mutableListOf<JSONObject>()
        for (i in 0 until jsonArray.length()) {
            val obj = jsonArray.getJSONObject(i)
            val preview = obj.getString("text").take(40) + "..."
            listItems.add(preview)
            texts.add(obj)
        }
        val adapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, listItems)
        AlertDialog.Builder(this)
            .setTitle("Load Saved Text")
            .setAdapter(adapter) { dialog, which ->
                val obj = texts[which]
                binding.pinnedEditText.setText(obj.getString("text"))
                binding.pinnedEditText.pinnedStart =
                    if (obj.isNull("pinnedStart")) null else obj.getInt("pinnedStart")
                binding.pinnedEditText.pinnedEnd =
                    if (obj.isNull("pinnedEnd")) null else obj.getInt("pinnedEnd")
                // If both pins exist, update selection.
                if (binding.pinnedEditText.pinnedStart != null && binding.pinnedEditText.pinnedEnd != null) {
                    val start = minOf(
                        binding.pinnedEditText.pinnedStart!!,
                        binding.pinnedEditText.pinnedEnd!!
                    )
                    val end = maxOf(
                        binding.pinnedEditText.pinnedStart!!,
                        binding.pinnedEditText.pinnedEnd!!
                    )
                    binding.pinnedEditText.setSelection(start, end)
                }
            }
            .setNegativeButton("Cancel", null)
            .show()
    }
}




// app/src/main/java/com/example/textselector/PinnedEditText.kt
package com.example.textselector

import android.content.Context
import android.util.AttributeSet
import android.view.*
import android.widget.Button
import android.widget.PopupWindow
import androidx.appcompat.widget.AppCompatEditText
import kotlin.math.max
import kotlin.math.min

class PinnedEditText @JvmOverloads constructor(
    context: Context,
    attrs: AttributeSet? = null,
    defStyleAttr: Int = android.R.attr.editTextStyle
) : AppCompatEditText(context, attrs, defStyleAttr) {

    // Pinned boundaries (null means not yet set)
    var pinnedStart: Int? = null
    var pinnedEnd: Int? = null

    // Detect double-taps.
    private val gestureDetector = GestureDetector(context, object : GestureDetector.SimpleOnGestureListener() {
        override fun onDoubleTap(e: MotionEvent): Boolean {
            val offset = getOffsetForPosition(e.x, e.y)
            // If both pins are set, reset to start a new selection.
            if (pinnedStart != null && pinnedEnd != null) {
                pinnedStart = null
                pinnedEnd = null
                setSelection(offset)  // clear selection
            }
            showPinPopup(e.x, e.y, offset)
            return true
        }
    })

    override fun onTouchEvent(event: MotionEvent): Boolean {
        gestureDetector.onTouchEvent(event)
        return super.onTouchEvent(event)
    }

    /**
     * Displays a popup near the tapped position.
     * Depending on the current pin state, it shows:
     *  - Only "Pin Start" (if no start pin exists)
     *  - "Unpin Start" and "Pin End" (if start is set but not end)
     */
    private fun showPinPopup(tapX: Float, tapY: Float, offset: Int) {
        // Inflate the popup layout defined in res/layout/popup_pin_options.xml
        val popupView = LayoutInflater.from(context).inflate(R.layout.popup_pin_options, null)
        val buttonOption1 = popupView.findViewById<Button>(R.id.buttonOption1)
        val buttonOption2 = popupView.findViewById<Button>(R.id.buttonOption2)

        // Create the PopupWindow.
        val popupWindow = PopupWindow(
            popupView,
            WindowManager.LayoutParams.WRAP_CONTENT,
            WindowManager.LayoutParams.WRAP_CONTENT,
            true
        )
        popupWindow.isOutsideTouchable = true
        // A background drawable is needed for outside taps to dismiss the popup.
        popupWindow.setBackgroundDrawable(context.getDrawable(android.R.drawable.alert_light_frame))

        if (pinnedStart == null) {
            // No start pin: show only the "Pin Start" option.
            buttonOption1.text = "Pin Start"
            buttonOption1.setOnClickListener {
                val (wordStart, wordEnd) = selectWordAt(offset)
                pinnedStart = wordStart
                // Select the tapped word.
                setSelection(wordStart, wordEnd)
                popupWindow.dismiss()
            }
            buttonOption2.visibility = View.GONE
        } else if (pinnedStart != null && pinnedEnd == null) {
            // Start pin exists; now allow unpinning or pinning the end.
            buttonOption1.text = "Unpin Start"
            buttonOption1.setOnClickListener {
                pinnedStart = null
                setSelection(offset)  // clear selection
                popupWindow.dismiss()
            }
            buttonOption2.visibility = View.VISIBLE
            buttonOption2.text = "Pin End"
            buttonOption2.setOnClickListener {
                val (wordStart, wordEnd) = selectWordAt(offset)
                // Use the word's end offset so that the tapped word is fully selected.
                pinnedEnd = wordEnd
                // Select all text between the start and end pins.
                val selStart = min(pinnedStart!!, pinnedEnd!!)
                val selEnd = max(pinnedStart!!, pinnedEnd!!)
                setSelection(selStart, selEnd)
                popupWindow.dismiss()
            }
        }

        // Calculate absolute screen coordinates.
        val location = IntArray(2)
        getLocationOnScreen(location)
        val anchorX = location[0] + tapX.toInt()
        val anchorY = location[1] + tapY.toInt()
        popupWindow.showAtLocation(this, Gravity.NO_GRAVITY, anchorX, anchorY)
    }

    /** Determines the word boundaries (start, end) for the word at the given offset. */
    private fun selectWordAt(offset: Int): Pair<Int, Int> {
        val textStr = text?.toString() ?: ""
        if (textStr.isEmpty()) return Pair(0, 0)
        var start = offset
        var end = offset
        while (start > 0 && !textStr[start - 1].isWhitespace()) {
            start--
        }
        while (end < textStr.length && !textStr[end].isWhitespace()) {
            end++
        }
        return Pair(start, end)
    }
}



// app/src/main/res/layout/popup_pin_options.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    style="?android:attr/buttonBarStyle"
    android:orientation="horizontal"
    android:padding="8dp"
    android:background="@android:color/white"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content">

    <Button
        android:id="@+id/buttonOption1"
        style="?android:attr/buttonBarButtonStyle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="" />

    <Button
        android:id="@+id/buttonOption2"
        style="?android:attr/buttonBarButtonStyle"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text=""
        android:layout_marginStart="8dp"/>
</LinearLayout>



// app/src/main/res/layout/activity_main.xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!-- Command bar -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="8dp">

        <Button
            android:id="@+id/pasteButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/paste" />

        <EditText
            android:id="@+id/searchEditText"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:autofillHints=""
            android:hint="@string/search_term"
            android:inputType="text" />

        <Button
            android:id="@+id/searchButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/search" />

        <Button
            android:id="@+id/saveButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/save" />

        <Button
            android:id="@+id/loadButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="@string/load" />
    </LinearLayout>

    <!-- The main text area -->
    <com.example.textselector.PinnedEditText
        android:id="@+id/pinnedEditText"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:background="@android:color/white"
        android:padding="16dp"
        android:textIsSelectable="true" />
</LinearLayout>



// app/src/main/res/menu/custom_selection_menu.xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto">
    <item
        android:id="@+id/action_pin_start"
        android:title="@string/pin_start"
        app:showAsAction="ifRoom" />
    <item
        android:id="@+id/action_pin_end"
        android:title="@string/pin_end"
        app:showAsAction="ifRoom" />
</menu>



//app/src/main/AndroidManifest.xml
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.example.textselector"
    xmlns:android="http://schemas.android.com/apk/res/android">

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="TextSelector"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.AppCompat.Light.NoActionBar">
        <activity android:name=".MainActivity" android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
            <!-- Allow the app to appear in the “Share” menu for text -->
            <intent-filter>
                <action android:name="android.intent.action.SEND"/>
                <category android:name="android.intent.category.DEFAULT"/>
                <data android:mimeType="text/plain"/>
            </intent-filter>
        </activity>
    </application>
</manifest>




// app/build.gradle.kts
plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
}

android {
    namespace = "com.example.textselector"
    compileSdk = 35

    defaultConfig {
        applicationId = "com.example.textselector"
        minSdk = 24
        targetSdk = 35
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }
    kotlinOptions {
        jvmTarget = "11"
    }
    buildFeatures {
        viewBinding = true
    }

}

dependencies {

    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.appcompat)
    implementation(libs.material)
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)
}